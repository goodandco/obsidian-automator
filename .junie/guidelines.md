ProjectFlow — Development Guidelines

This document captures project‑specific knowledge for advanced contributors to the ProjectFlow Obsidian plugin.

1. Build and Configuration
- Toolchain
  - TypeScript 4.7.4, esbuild 0.17.x, Node 16+ compatible.
  - Entry point: main.ts; bundle target: CJS, ES2018; externals: obsidian, electron, CodeMirror, Node builtins.
  - Output: main.js in repo root (required by Obsidian alongside manifest.json and styles.css).
- Commands
  - Development (watch): npm run dev → node esbuild.config.mjs
  - Production build: npm run build → tsc type-check (no emit) + esbuild production bundle
- Build Details (esbuild.config.mjs)
  - Uses esbuild.context; watch in dev, single rebuild in production.
  - Banner is injected at top of main.js: "THIS IS A GENERATED/BUNDLED FILE BY ESBUILD".
  - Sourcemaps inline in dev; minified in production; tree shaking enabled.
  - Externalized modules avoid bundling Obsidian/CM/etc.; this is required for Obsidian runtime.
- TypeScript (tsconfig.json)
  - strict-ish: noImplicitAny, strictNullChecks, isolatedModules.
  - module: ESNext, target: ES6; moduleResolution: node.
  - inlineSourceMap/inlineSources enabled for dev experience.
- Obsidian Plugin Layout
  - manifest.json must match folder name (id: project-flow). Place under <vault>/.obsidian/plugins/project-flow.
  - Files Obsidian loads: manifest.json, main.js, styles.css.
  - The plugin expects template files inside the vault: .obsidian/plugins/project-flow/src/templates/* (see README → Troubleshooting). During development, ensure those exist if you test inside Obsidian.

2. Testing
There is no test framework configured in this repository. Importing plugin code in Node is non-trivial because the runtime module "obsidian" is externalized and not available outside the Obsidian app. Practical approaches:
- Build verification tests (recommended minimal): Verify that the production build succeeds and produces a bundled main.js with the expected banner. This is safe to run in CI/CLI and validates the toolchain.
- Unit testing pure helpers (future work): Extract pure functions that do not depend on obsidian (e.g., generateProjectVariables, processTemplate) into a separate module that can be imported in Node, or provide a lightweight alias/mock for "obsidian" in the test environment.

2.1. Running a Minimal Build Test (demonstration)
- Create a temporary file scripts/build.test.mjs with the following content:

  import { execSync } from 'node:child_process';
  import { readFileSync, statSync } from 'node:fs';

  function run(cmd) {
    execSync(cmd, { stdio: 'inherit' });
  }
  function assert(condition, message) {
    if (!condition) throw new Error(message);
  }
  try {
    console.log('[test] Running production build...');
    run('npm run build');

    console.log('[test] Verifying main.js exists...');
    const stat = statSync('main.js');
    assert(stat.isFile(), 'main.js is not a file');
    assert(stat.size > 1000, `main.js seems too small: ${stat.size}`);

    console.log('[test] Checking esbuild banner presence...');
    const content = readFileSync('main.js', 'utf8');
    assert(content.includes('THIS IS A GENERATED/BUNDLED FILE BY ESBUILD'), 'Banner not found in main.js');

    console.log('[test] SUCCESS: Build produced a bundled main.js with expected banner.');
  } catch (e) {
    console.error('[test] FAILURE:', e.message || e);
    process.exit(1);
  }

- Execute the test:
  - node scripts/build.test.mjs
- Expected output includes: "SUCCESS: Build produced a bundled main.js with expected banner."
- Cleanup: Remove the temporary test file after validation to keep the repository clean.

2.2. Adding New Tests (guidelines)
- For build/packaging assertions, prefer Node ESM scripts under scripts/*.mjs that shell out to the existing npm scripts and then validate artifacts.
- For logic-level unit tests:
  - Refactor pure logic into a separate module (e.g., src/lib/project-vars.ts) that has no obsidian import. Export functions like generateProjectVariables and processTemplate from there, and have plugin.ts consume them. This allows direct import in tests without stubbing the Obsidian runtime.
  - Choose a lightweight runner (e.g., vitest) if adding a framework. Configure it to use ts-node or pre-bundle via esbuild to keep parity with project build. Do not attempt to instantiate Obsidian classes in Node; mock minimal shapes where necessary.
- Avoid relying on Obsidian runtime in tests; keep tests hermetic and focused on build or pure logic.

3. Additional Development Information
- Code Style
  - .editorconfig: UTF-8, LF, 2-space indentation, final newline.
  - Keep TypeScript strictness as configured; avoid any unless warranted by Obsidian API gaps.
- Plugin Architecture (high-level)
  - src/plugin.ts: AutomatorPlugin orchestrates prompts and project creation; contributes command id: add-project-info; integrates settings tab.
  - src/settings-tab.ts: Settings UI for Dimensions/Categories, supports add/rename/delete with confirm-to-reset (ConfirmResetModal). Uses Obsidian DOM helpers and lucide icons via setIcon.
  - src/input-modal.ts, src/confirm-reset-modal.ts: Simple modals for input/confirm flows.
  - src/interfaces.ts: Type contracts for settings, prompt payloads, and template variables.
  - Template handling: createProjectFile reads from .obsidian/plugins/<manifest.id>/src/templates/*.md inside the vault, replaces $_VARIABLE tokens, and writes notes under 1. Projects/<Dimension>/<Category>/<ProjectFullName> plus a project-specific Templates/<Name>_Templates/ folder.
- Tips for Local Development
  - For rapid iteration in Obsidian: run npm run dev, then in Obsidian, toggle plugin off/on or use Force reload. Keep styles.css in plugin root; Obsidian auto-loads it.
  - When testing template creation inside a real vault, ensure the templates directory exists where the plugin expects it; otherwise project creation will fail with "Template file not found".
  - manifest.json: ensure id matches plugin folder name (project-flow). minAppVersion currently 0.12.0; adjust as needed for newer API usage.
- Versioning and Distribution
  - Keep package.json version and manifest.json version aligned for clarity.
  - The generated main.js includes a banner; do not edit main.js by hand. Always rebuild for changes.

Appendix: Verified Commands (2025-09-29)
- npm run build → succeeded locally; produced main.js with expected banner.
- Temporary test script node scripts/build.test.mjs → passed, confirming the build output. The script should be removed after use.
